-- | main 函数是程序的入口点。
-- `IO ()` 表示这是一个会产生副作用（比如打印到控制台）的IO操作，且不返回任何有意义的值。
main :: IO ()
main = do
  -- `putStrLn` 用于将字符串打印到控制台并换行。
  -- `show` 是一个类型类函数，可以将一个值转换成它的字符串表示。
  -- `fib 10` 计算第10个斐波那契数。
  -- `map fib [1..10]` 会将 `fib` 函数应用到列表 `[1..10]` 的每个元素上，生成一个新的列表。
  putStrLn "Haskell 特色代码示例：斐波那契数列"
  putStrLn "======================================"
  putStrLn $ "第10个斐波那契数是: " ++ show (fib 10)
  putStrLn $ "前10个斐波那契数是: " ++ show (map fib [1 .. 10])
  putStrLn $ "使用惰性求值和无限列表计算的前10个斐波那契数: " ++ show (take 10 fibs)

-- | `fib` 函数计算第n个斐波那契数。
-- `Int -> Int` 是函数的类型签名，表示它接受一个 `Int` 类型的参数并返回一个 `Int` 类型的值。
-- 这是一个纯函数，它的返回值只依赖于输入 `n`。
fib :: Int -> Int
-- 模式匹配：
-- 当输入是 0 时，返回 0。这是基本情况。
fib 0 = 0
-- 当输入是 1 时，返回 1。这是另一个基本情况。
fib 1 = 1
-- 对于任何其他大于1的整数 `n`，递归地计算 `fib (n-1)` 和 `fib (n-2)` 的和。
-- 这种定义方式非常直观，直接反映了斐波那契数列的数学定义。
fib n = fib (n - 1) + fib (n - 2)

-- | `fibs` 是一个无限的斐波那契数列列表。
-- 这展示了Haskell的惰性求值（Lazy Evaluation）特性。
-- 整个列表不会一次性在内存中生成，只有在需要时才会计算列表中的元素。
fibs :: [Integer]
-- `0 : 1 : zipWith (+) fibs (tail fibs)` 是一个非常优雅的定义方式：
-- 1. 列表以 0 和 1 开始。
-- 2. `zipWith (+)` 会将两个列表对应位置的元素相加。
-- 3. `fibs` 是整个无限列表。
-- 4. `tail fibs` 是 `fibs` 去掉第一个元素后的列表。
-- 5. `zipWith (+) fibs (tail fibs)` 的结果是 (fibs[0]+fibs[1]), (fibs[1]+fibs[2]), ...
--    这恰好是斐波那契数列的定义：F(n) = F(n-1) + F(n-2)
--    例如：
--    fibs       = 0 : 1 : 1 : 2 : 3 : ...
--    tail fibs  = 1 : 1 : 2 : 3 : 5 : ...
--    zipWith (+) = 1 : 2 : 3 : 5 : 8 : ...
--    所以 fibs = 0 : 1 : (1 : 2 : 3 : 5 : 8 : ...)
fibs = 0 : 1 : zipWith (+) fibs (tail fibs)

-- | `take` 是一个高阶函数，它接受一个数字 `n` 和一个列表，返回列表的前 `n` 个元素。
-- `take :: Int -> [a] -> [a]`
-- 在 `main` 函数中，`take 10 fibs` 会从无限列表 `fibs` 中取出前10个元素，而不会导致无限循环。
